{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 学习笔记 powered by GitbookYoung, 该文件最后修改时间： 2021-04-10 16:04:29 "},"设计模式/readme.html":{"url":"设计模式/readme.html","title":"设计模式","keywords":"","body":"GOF23设计模式相关笔记 powered by GitbookYoung, 该文件最后修改时间： 2021-04-10 16:06:05 "},"设计模式/概述.html":{"url":"设计模式/概述.html","title":"设计模式概述","keywords":"","body":" 简介 设计模式的七种原则 单一职责原则 开闭原则 里氏替换原则 依赖倒置原则 接口隔离原则 迪米特法则 合成/聚合原则 23种设计模式的分类 简介 设计模式(Design Pattern)是经过高度抽象化的在编程中可以被反复使用的代码设计经验的总结 简单说设计模式就是经过实践验证的良好的编码经验 这里说的设计模式指的是GOF23，GOF指： 在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版> 了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：> 设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。 四位作者合称 GOF（四人帮，全拼 Gang of Four）。 设计模式的七种原则 单一职责原则 就是一个类只有一个职责。 开闭原则 软件中的对象(类、模块、函数等)对扩展开放，对修改关闭；这意味着一个实体在不改变其源代码的前提下改变其行为。 里氏替换原则 里氏替换原则是对开闭原则的补充，规定了在任意父类可以出现的地方，其子类一定可以出现。一般面向对象的编程语言都支持该特性。 依赖倒置原则 程序依赖于抽象类，而不是具体的实现类，即面向接口编程。 接口隔离原则 不同的功能应该定义在不同的接口中，其实就是单一职责原则 迪米特法则 又名最少知道原则，就是一个实体应当尽量少地与其他实体之间发生相互作用，其核心思想在于降低模块之间的耦合度 合成/聚合原则 在新的对象中引入其他对象以达到类的功能服用和扩展的目的 23种设计模式的分类 设计模式按照其功能和使用场景可以分为3大类：创建型、结构型和行为型 类型 说明 设计模式 创建型 提供多种优雅创建对象的方法 简单工厂(不是23种之一但应用广泛) 工厂方法 抽象工厂 单例模式 建造者模式 原型模式 结构型 通过类和接口之间的继承和引用实现创建复杂结构对象 适配器模式 桥接模式 过滤器模式 组合模式 装饰器模式 外观模式 享元模式 代理模式 行为型 通过类之间不同的通信方式实现不同的行为方式 责任链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板模式 访问者模式 powered by GitbookYoung, 该文件最后修改时间： 2021-05-08 21:33:44 "},"设计模式/工厂模式.html":{"url":"设计模式/工厂模式.html","title":"工厂模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-04-10 16:57:25 "},"设计模式/单例模式.html":{"url":"设计模式/单例模式.html","title":"单例模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-04-10 16:10:17 "},"设计模式/建造者模式.html":{"url":"设计模式/建造者模式.html","title":"建造者模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-04-10 16:10:36 "},"设计模式/原型模式.html":{"url":"设计模式/原型模式.html","title":"原型模式","keywords":"","body":"powered by GitbookYoung, 该文件最后修改时间： 2021-04-10 16:10:55 "},"唯一ID/unique_id.html":{"url":"唯一ID/unique_id.html","title":"分布式唯一ID","keywords":"","body":"分布式唯一ID 1. 背景 我们在设计和实现互联网系统时，往往需要使用到唯一ID。唯一ID标识唯一的一条业务请求，如在电商系统中，ID表示系统中唯一的一个订单，支付系统中表示唯一的一条交易请求。在单机应用中，唯一ID的生成是比较简单的，我们只需保证ID在单机上面是唯一的即可；但目前互联网应用多为微服务应用，同时随着业务的逐渐增长，必须对业务进行分库分表，而且业务应用往往是多实例部署的，这就要求ID在多个微服务应用和多个应用实例之间是唯一。目前业界有很多成熟的唯一ID生成方案，下面我们来看下这些分布式唯一的ID生成方案。 2. 概念 2.1 什么是分布式唯一ID 我的理解是；分库分表应用中多实例、各微服务应用之间全局唯一的ID即是分布式式唯一ID。 2.2 分布式唯一ID的特性 全局唯一：唯一ID，顾名思义； 高性能：ID生成的性能要高，否则会影响业务系统的性能； 高可用：ID生成服务要是高可用的，否则一旦出现不可用则会影响业务系统的可用性； 递增；尽量保证是递增的，因为业务系统可能需要根据ID进行排序，分为单调递增和趋势递增； 长度：长度尽可能的短； 侵入性小：尽量做到对业务系统无侵入。 此外，根据业务的不同，还可能要存在其他特性： 时间：有的ID中需要包含时间戳； 业务含义：这个要看具体的业务需求。 2.3 单调递增和趋势递增 单调递增：ID是严格递增的，后面的请求ID一定比之前的请求的ID大； 趋势递增：ID的整体趋势是递增的，不过存在后面的请求的ID比之前的请求ID小的情况。比如这样的ID生成方案：考虑这样的一个场景，2个实例的业务应用，实例1缓存0-1000的ID在进程中，实例2缓存1001-2000的ID在进程中，请求1先请求实例2（随机负载均衡），ID为1001，然后1分钟后请求2请求实例1，ID为0，即出现后面的请求的ID比之前的请求的ID小的情况，但是ID分配的整体趋势是递增的。 2.4 设计分布式ID系统需注意的点 时钟回退：如果ID中包含时间戳信息，需考虑时钟回退的场景，如果出现时钟回退则可能出现重复ID； 多线程问题：ID生成往往是在多线程的环境下的，因此需要注意多线程问题； 数据库性能：有些ID生成算法依赖数据库中的记录，需要考虑数据库的性能问题以及多线程引发的数据库锁问题 2.5 分布式ID系统的难点 ID长度尽可能的短：我们的ID大多数是需要在数据库中存储的，越长的ID占用的空间越多；如果使用该ID作为MySQL的主键，主键也是要求尽可能的短的，所以ID长度要尽可能的短。随之而来的问题是，越短的ID，其中包含的信息越少（信息熵越小），冲突的可能性就越大； 多线程问题：多实例之间，同一实例之间的线程都会抢ID，因此必须注意多线程问题，解决方法大部分是加锁，如果线程之间竞争严重，则严重形象性能。 3. 分布式ID生成方案 3.1 UUID 3.2 MySQL自增 3.3 数据库集群模式 3.4 数据库号段模式 3.5 Redis/Zookeeper 3.6 雪花算法 3.7 美团Leaf算法 3.8 百度uid-generator 3.9 滴滴TinyId powered by GitbookYoung, 该文件最后修改时间： 2021-05-19 22:22:32 "}}